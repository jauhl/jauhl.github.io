<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Drehwinkelzuordnung nach Volmer</title>
    <style>
        html, body {
            margin: 0px;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
    <canvas id="c2"></canvas>
<!--      
    <script src="./libs/g2.min.js"></script>
    <script src="./libs/g2.mec.min.js"></script>
    <script src="./libs/quicksettings.min.js"></script>
    <script src="./libs/v2.min.js"></script>
-->    
    <script src="https://gitcdn.xyz/repo/goessner/g2/master/g2.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/g2-mec/master/g2.mec.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/v2/master/v2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/quicksettings/latest/quicksettings.min.js"></script> 

    <script>

function position() {
    g.del().style({foc:"white"})

    if (evaluated && panel.getValue("Mechanismus sichtbar")) {
        g.lin(mec.A0.x, mec.A0.y, mec.A1.x, mec.A1.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.5)"})
         .lin(mec.B0.x, mec.B0.y, mec.B1.x, mec.B1.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.5)"})
         .bar2(mec.A0,mec.A)
         .bar2(mec.A,mec.B)
         .bar2(mec.B0,mec.B)
         .use("nod",mec.A)
            .label("A","nw")
         .use("nod",mec.B)
            .label("B","nw")
        if (-(mec.phi_1-mec.phi)>0.5/180*pi) {
             g.avec(mec.A0, 0.25*mec.a, mec.phi_1, -(mec.phi_1-mec.phi), {ls:"rgba(255, 177, 50, 0.8)"})
                .label(`${+((mec.phi-mec.phi_1)*180/pi).toFixed(2)}°`,"mid","right")
        }
        if (-(mec.psi_1-mec.psi)>0.5/180*pi) {
             g.avec(mec.B0, 0.4*mec.c, mec.psi_1, -(mec.psi_1-mec.psi), {ls:"rgba(255, 177, 50, 0.8)"})
                .label(`${+((mec.psi-mec.psi_1)*180/pi).toFixed(2)}°`,"mid","right")
        }
    }
    g.use("nodfix",mec.B0).label("B0","se")
}

function getPsi(angl) {
    var origphi = mec.phi,
        psiphi = 0;

    mec.phi = angl;
    psiphi = mec.psi;
    mec.phi = origphi;

    return psiphi;
}

function construct() {
    construction.del().clr().cartesian().style({foc:"white"})

        // Schritt 1
        if(mec.step >= 1) {
            construction.lin(mec.A0.x, mec.A0.y, mec.A1.x, mec.A1.y, { ls:"rgba(255, 255, 255, 0.8)"})
                        .use("nod",mec.A1).label("A1","nw")
        }

        // Schritt 2
        if(mec.step >= 2) {
            construction.lin(mec.A0.x, mec.A0.y, mec.A2.x, mec.A2.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.8)"})
                            .label("A2","end","left")
                        .lin(mec.A0.x, mec.A0.y, mec.A3.x, mec.A3.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.8)"})
                            .label("A3","end","left")
                        .use("nod",mec.A2)
                        .use("nod",mec.A3)
                        .beg({foz:"12", foc:"papayawhip"})
                            .avec(mec.A0, 0.2*mec.a, mec.phi_1, mec.phi_i[0], {ls:"rgba(255, 177, 50, 0.8)"})
                                .label("φ12","mid","right")
                            .avec(mec.A0, 0.3*mec.a, mec.phi_1, mec.phi_i[1], {ls:"rgba(255, 177, 50, 0.8)"})
                                .label("φ13","mid","right")
                        .end()
        }

        // Schritt 3
        if(mec.step >= 3) {
            construction.lin(mec.B0.x, mec.B0.y, mec.A2.x, mec.A2.y, {ls:"rgba(255, 255, 255, 0.8)"})
                        .lin(mec.B0.x, mec.B0.y, mec.A3.x, mec.A3.y, {ls:"rgba(255, 255, 255, 0.8)"})
        }

        // Schritt 4
        if(mec.step >= 4) {
            construction.lin(mec.B0.x, mec.B0.y, mec.A21.x, mec.A21.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.8)"})
                           .label("A21","end","left")
                        .lin(mec.B0.x, mec.B0.y, mec.A31.x, mec.A31.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.8)"})
                           .label("A31","end","left")
                        .use("nod",mec.A21)
                        .use("nod",mec.A31)
                        .beg({foz:"12", foc:"papayawhip"})
                            .avec(mec.B0, (mec.lenB0A2<mec.lenB0A3)?0.3*mec.lenB0A2:0.3*mec.lenB0A3, mec.psiB0A2, -mec.psi_i[0], {ls:"rgba(255, 177, 50, 0.8)"})
                                .label("- ψ12","mid","right")
                            .avec(mec.B0, (mec.lenB0A2<mec.lenB0A3)?0.5*mec.lenB0A2:0.5*mec.lenB0A3, mec.psiB0A3, -mec.psi_i[1], {ls:"rgba(255, 177, 50, 0.8)"})
                                .label("- ψ13","mid","right")
                        .end()
        }

        // Schritt 5
        if(mec.step >= 5) {
            construction.ply([mec.A1, mec.A21, mec.A31], false, {ls:"rgba(255, 255, 255, 0.8)", fs:"transparent"})
                        .ply([mec.midA1A21, mec.B1, mec.midA21A31], false, {ld:"@dot", ls:"rgba(255, 255, 255, 0.9)", fs:"transparent"})
                        .beg({x: mec.midA1A21.x, y: mec.midA1A21.y, w:pi+mec.psiA1A21})
                            .rec(0, 0, 6, 6, {lw:2, ls:"rgba(126, 126, 118, 0.9)", fs:"rgba(255, 255, 255, 0.6)"})
                        .end()
                        .beg({x: mec.midA21A31.x, y: mec.midA21A31.y, w:pi+mec.psiA21A31})
                            .rec(0, 0, 6, 6, {lw:2, ls:"rgba(126, 126, 118, 0.9)", fs:"rgba(255, 255, 255, 0.6)"})
                        .end()
                        .use("nod",mec.B1)
                           .label("B1","nw")
        }
    construction.exe(ctx2);

}

function render() {
    if (dirty) {
        position();
        world.exe(ctx);
        dirty = false;
    }
    requestAnimationFrame(render);
}

function updateLinks() {
    panel.setValue("Gliedlängen:", `b = ${mec.b.toFixed(2)} \nc = ${mec.c.toFixed(2)}`);
}

function updateStep() {
    panel.setValue("aktueller Schritt:", steps[mec.step]);
}

function norm(value, min, max) {
    return (value - min)/(max - min);
}

// cross product; takes objects with at least 2 dimensions and returns a 3d object
function cross(a,b) {
    var az = (a.z != 0) ? (a.z || 1) : 0,
        bz = (b.z != 0) ? (b.z || 1) : 0;

    return {x: a.y*bz - az*b.y , y: az*b.x - a.x*bz , z: a.x*b.y  -  a.y*b.x};
}

function evaluate() {
    var phimin = mec.phi_1,
        phimax = mec.phi_1 + Math.max(...mec.phi_i);

    panel.setRangeParameters("φ", Math.round(phimin*180/pi), Math.round(phimax*180/pi), 1);

    panel.setValue("φ", Math.round(mec.phi_1*180/pi));

    mec.b = mec.lenb;
    mec.c = mec.lenc;

    mec.psi_1 = getPsi(mec.phi_1);

    updateLinks();
    console.log("a = " + mec.a + ",   b = " + mec.b + ",   c = " + mec.c  );

    evaluated = true;
    dirty = true;
}

function changePsis() {
    for (var i = 0; i < 3; i++) {
        mec.psi_i[i] -= mec.alpha;
    }
}

var cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    cnv2 = document.getElementById('c2'),
    ctx2 = cnv2.getContext('2d'),
    width = cnv.width = cnv2.width = window.innerWidth,
    height = cnv.height = cnv2.height = window.innerHeight,

    pi = Math.PI,

    mec = {
        phi:0,
        phi_1:30/180*pi, // construction parameter (starting angle)
        psi_1:0, // to be evaluated...
        phi_i:[30/180*pi,60/180*pi], // predefined angles
        psi_i:[40/180*pi,90/180*pi], // predefined angles
        a:410,
        b:0, //200
        c:0, //360
        d:200,

        step:0,
        largeNum:999999999,

        assembly:1,  // direction of mec. assembly, found in mue of theta

        //######################################################################
        //#            Loesung
        //######################################################################
        get A1() {
            return {x: this.A0.x + this.a*Math.cos(mec.phi_1),
                    y: this.A0.y + this.a*Math.sin(mec.phi_1)};
        },

        // step 2
        get A2() {
            return {x: this.A0.x + this.a*Math.cos(mec.phi_1 + mec.phi_i[0]),
                    y: this.A0.y + this.a*Math.sin(mec.phi_1 + mec.phi_i[0])};
        },

        get A3() {
            return {x: this.A0.x + this.a*Math.cos(mec.phi_1 + mec.phi_i[1]),
                    y: this.A0.y + this.a*Math.sin(mec.phi_1 + mec.phi_i[1])};
        },

        // step 3
        get lenB0A2() {
            return v2.len(v2.dif(this.B0, this.A2));
        },

        get lenB0A3() {
            return v2.len(v2.dif(this.B0, this.A3));
        },

        get psiB0A2() {
            var vec = v2.dif(mec.A2, mec.B0);
            return Math.atan2(vec.y,vec.x);
        },

        get psiB0A3() {
            var vec = v2.dif(mec.A3, mec.B0);
            return Math.atan2(vec.y,vec.x);
        },

        get A21() {
            return {x: this.B0.x + this.lenB0A2*Math.cos(mec.psiB0A2 - mec.psi_i[0]),
                    y: this.B0.y + this.lenB0A2*Math.sin(mec.psiB0A2 - mec.psi_i[0])};
        },

        get A31() {
            return {x: this.B0.x + this.lenB0A3*Math.cos(mec.psiB0A3 - mec.psi_i[1]),
                    y: this.B0.y + this.lenB0A3*Math.sin(mec.psiB0A3 - mec.psi_i[1])};
        },

        // step 4
        get lenA1A21() {
            return v2.len(v2.dif(this.A1, this.A21));
        },

        get lenA21A31() {
            return v2.len(v2.dif(this.A21, this.A31));
        },

        get psiA1A21() {
            var vec = v2.dif(mec.A21, mec.A1);
            return Math.atan2(vec.y,vec.x);
        },

        get psiA21A31() {
            var vec = v2.dif(mec.A31, mec.A21);
            return Math.atan2(vec.y,vec.x);
        },

        get eA1A21() {
            return {x: Math.cos(mec.psiA1A21),
                    y: Math.sin(mec.psiA1A21)}
        },

        get eA21A31() {
            return {x: Math.cos(mec.psiA21A31),
                    y: Math.sin(mec.psiA21A31)}
        },

        get midA1A21() {
            return v2.isum(v2.scl(mec.eA1A21, 0.5*mec.lenA1A21) ,mec.A1);
        },

        get midA21A31() {
            return v2.isum(v2.scl(mec.eA21A31, 0.5*mec.lenA21A31) ,mec.A21);
        },

        get B1() {
            var P1 =  v2.isum(v2.iscl(v2.tilde(mec.eA1A21), -mec.largeNum) ,mec.midA1A21),
                P2 =  v2.isum(v2.iscl(v2.tilde(mec.eA1A21), mec.largeNum) ,mec.midA1A21),
                P3 =  v2.isum(v2.iscl(v2.tilde(mec.eA21A31), -mec.largeNum) ,mec.midA21A31),
                P4 =  v2.isum(v2.iscl(v2.tilde(mec.eA21A31), mec.largeNum) ,mec.midA21A31),
                SP = cross(  cross(P1,P2),   cross(P3,P4) );

            return {x: SP.x/SP.z, y: SP.y/SP.z};
        },

        // Gliedlaenge c
        get lenc() { // enspricht lenB0B1
            return v2.len(v2.dif(this.B0, this.B1));
        },

        // Gliedlaenge b
        get lenb() { // enspricht lenA1B1
            return v2.len(v2.dif(this.B1, this.A1));
        },



        //######################################################################
        //#            Kinematik
        //######################################################################

        get ephi() {
            return { x:Math.cos(this.phi), y:Math.sin(this.phi) };
        },

        get g() {
            return {x:this.d - this.a*Math.cos(this.phi), y:- this.a*Math.sin(this.phi)};
        },

        get gg() {
            return this.a*this.a + this.d*this.d - 2*this.a*this.d*Math.cos(this.phi);
        },

        get theta() {
            var gg = this.gg, bb_gg = (this.b*this.b)/gg, g = this.g,
                lambda = 0.5*(bb_gg - this.c*this.c/gg + 1),
                mue = mec.assembly*Math.sqrt(bb_gg - lambda*lambda);
            return Math.atan2( (1/this.b)*(lambda*g.y + mue*g.x), (1/this.b)*(lambda*g.x - mue*g.y) )
        },

        get etheta() {
            return { x:Math.cos(this.theta), y:Math.sin(this.theta)};
        },

        get psi() {
            var etheta = this.etheta;
            return Math.atan2( (1/this.c)*(this.b*etheta.y - this.g.y), (1/this.c)*(this.b*etheta.x - this.g.x) )
        },

        get epsi() {
            return { x:Math.cos(this.psi), y:Math.sin(this.psi)};
        },

        //######################################################################
        //#            Punkte
        //######################################################################

        A0: {x:0, y:0},

        get B0() {
            return {x:this.d, y:0}
        },

        get A() {
            return {x:this.A0.x + this.a*this.ephi.x, y:this.A0.y + this.a*this.ephi.y};
        },

        get B() {
            return {x:this.B0.x + this.c*this.epsi.x, y:this.B0.y + this.c*this.epsi.y};
        }
    },

    g = g2(),
    construction = g2().pan(0.4*width, 0.3*height),
    pol = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(255, 153, 0, 0.8)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    pol2 = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(129, 165, 148, 1)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    world = g2().clr().cartesian().style({foc:"white"})
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan(0.4*width, 0.3*height) // .pan((width - 400)/2, (height - 360)/2)
                .use(g)
                .use("nodfix").label("A0","se"),

    dirty = true,
    evaluated = false,
    init = false,

    steps = {
        0: "Gegeben seien Gliedlänge a, Gestellabstand d, Montagewinkel φ1 des Gliedes a sowie zwei Drehwinkelpaare φ1iψ1i",
        1: "Punkt A1 liegt im Abstand a von A0 um φ1 zur x-Achse verdreht.",
        2: "Mit φ12 und φ13 ergeben sich ausgehend von A1 die Punkte A2 und A3",
        3: "Die Verbindung der Punkte A2 und A3 mit B0 schafft zwei Hilfsgeraden ..",
        4: ".. die bei Drehung mit - ψ12 und - ψ13 um B0 auf die Punkte A21 und A31 führen.",
        5: "Die Mittelsenkrechten der Strecken A1A21 und A21A31 schneiden sich im Punkt B1."
    },

    panel = QuickSettings.create(10, 10, "Steuerung")
             .addImage("","https://jauhl.github.io/img/fhlogo.svg")

             .addProgressBar("Fortschritt", 5, mec.step, "numbers")

             .addButton("Schritt weiter ▶", function(value) { if(mec.step<5) {mec.step+=1; dirty = true; construct(); updateStep(); panel.setValue("Fortschritt", mec.step);} }) // ▶
             .addButton("Schritt zurück ◀", function(value) { if(mec.step>0) {mec.step-=1; dirty = true; construct(); updateStep(); panel.setValue("Fortschritt", mec.step);} }) // ◀

             .addRange("φ", 0, 360, mec.phi, 1, function(value) { mec.phi = value/180*pi; dirty = true;})

             .addBoolean("Mechanismus sichtbar", false, function() {dirty = true;})

             .addNumber("a", 0, 500, mec.a, 1, function(value) { mec.a = value;  dirty = true; evaluated = false; evaluate(); construct();})
             .addNumber("d", 0, 500, mec.d, 1, function(value) { mec.d = value;  dirty = true; evaluated = false; evaluate(); construct();})

             .addButton("Montagerichtung umkehren", function(value) { mec.assembly *= -1; mec.psi_1 = getPsi(mec.phi_1); dirty = true;})

             .addTextArea("Gliedlängen:")
             .addTextArea("aktueller Schritt:")
             .setTextAreaRows("Gliedlängen:", 1)
             .setTextAreaRows("aktueller Schritt:", 6)
    ,

    panel3 = QuickSettings.create( width - 210, 10, "Winkelvorgaben")
             .addNumber("φ1", 0, 360, Math.round(mec.phi_1*180/pi), 1, function(value) { mec.phi_1 = value/180*pi; if (init) { construct(); dirty = true; evaluated = false; evaluate();}})
             .addNumber("φ12", 0, 360, Math.round(mec.phi_i[0]*180/pi), 1, function(value) { mec.phi_i[0] = value/180*pi; if (init) { construct(); dirty = true; evaluated = false; evaluate();}})
             .addNumber("φ13", 0, 360, Math.round(mec.phi_i[1]*180/pi), "any", function(value) { mec.phi_i[1] = value/180*pi; if (init) { construct(); dirty = true; evaluated = false; evaluate();}})
             .addNumber("ψ12", 0, 360, Math.round(mec.psi_i[0]*180/pi), 1, function(value) { mec.psi_i[0] = value/180*pi; if (init) { construct(); dirty = true; evaluated = false; evaluate();}})
             .addNumber("ψ13", 0, 360, Math.round(mec.psi_i[1]*180/pi), "any", function(value) { mec.psi_i[1] = value/180*pi; if (init) { construct(); dirty = true; evaluated = false; evaluate();}})
;



/*
 *  Eventlistener
 */

window.onresize = function() {
    width = cnv.width = cnv2.width = window.innerWidth;
    height = cnv.height = cnv2.height = window.innerHeight;

    panel3.setPosition( width - 210, 10);

    construction = g2().pan(0.4*width, 0.3*height);

    world = g2().del().clr().cartesian().style({foc:"white"})
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan(0.4*width, 0.3*height) // .pan((width - 400)/2, (height - 360)/2)
                .use(g)
                .use("nodfix").label("A0","se");

    dirty = true;
    construct();
};



/*
 *  Initialisierung
 */

if (panel._content.clientHeight > (height - 20)) panel.setHeight(height-20);  // resize qs panel if necessary
if (panel3._content.clientHeight > (height - 20)) panel.setHeight(height-20);  // resize qs panel if necessary
g2.State.linkfill = "transparent";
updateStep();
evaluate();
init = true;
render();

    </script>
</body>
</html>