<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Dreiwinkelzuordnung</title>    
    <style>
        html, body {
            margin: 0px;
        }
        .max-cnv {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #c3 {
            display: none;
            position: absolute;
        }
    </style>  
</head>

<body>       
    <canvas class="max-cnv" id="c"></canvas>
    <canvas class="max-cnv" id="c2"></canvas>
    <canvas id="c3" width="400" height="300"></canvas>    
<!--      
    <script src="./libs/g2.min.js"></script>
    <script src="./libs/g2.mec.min.js"></script>
    <script src="./libs/g2.chart.min.js"></script>
    <script src="./libs/quicksettings.min.js"></script>
    <script src="./libs/v2.min.js"></script>
-->
    <script src="https://gitcdn.xyz/repo/goessner/g2/master/g2.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/g2-mec/master/g2.mec.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/g2-chart/master/g2.chart.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/v2/master/v2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/quicksettings/latest/quicksettings.min.js"></script>  

    <script>
    
function position() {
    g.del().style({foc:"white"})
     
    if (evaluated) {
        g.bar2(mec.A0,mec.A)
         .bar2(mec.A,mec.B)
         .bar2(mec.B0,mec.B)

         .use("nod",mec.A).label("A","nw")
         .use("nod",mec.B).label("B","ne")
        
        if (mec.warped) {  // no 4-bar possible from these due to change in distance
            g.bar(mec.A0,{x:100*mec.ephi.x, y:100*mec.ephi.y}, {ls:"rgba(255, 177, 50, 0.6)"})
             .bar(mec.B0,{x:mec.B0.x + 100*mec.epsi.x, y:mec.B0.y + 100*mec.epsi.y}, {ls:"rgba(255, 177, 50, 0.6)"})
        }
    } 
    
    g.use("nodfix",mec.B0).label("B0","se")
}

function plotTransfunc() {
    if (evaluated) {
        g2().cartesian().clr().del().rec(0, 0, cnv3.width, cnv3.height, {fs:"rgba(238, 238, 238, 1)"} )
            .chart({ x:35,y:35,b:350,h:230,
                 title:{ text:"Übertragungsfunktion 0. Ordnung ψ(φ)"},
                         funcs:[
                          { data:mec.tf, 
                            fill:false
                          }
                         ],
                         xaxis: {
                           title:"φ",
                           grid:true
                         },
                         yaxis: {
                           title:"ψ",
                           grid:true,
                           origin:true
                         }
                       })
        .exe(ctx3);
    }  
}

function angles() {
        var xOff = 0.4*width, // (width - 400)/2
            yOff = 0.3*height; // (height - 360)/2

        angl.del().clr().cartesian().style({foc:"papayawhip", ld:"@dash", ls:"rgba(255, 255, 255, 0.8)"})         

        for (var i = 0; i < 3; i++) {
            angl.lin(xOff + mec.A0.x, yOff + mec.A0.y, xOff + mec.d*Math.cos(mec.phi_i[i]), yOff + mec.d*Math.sin(mec.phi_i[i])).label(`\u03C6${i+1}`,`end`,`right`)
                .lin(xOff + mec.B0.x, yOff + mec.B0.y, xOff + mec.B0.x + mec.d*Math.cos(mec.psi_i[i]), yOff + mec.B0.y + mec.d*Math.sin(mec.psi_i[i])).label(`\u03C8${i+1}`,`end`,`right`)  
            // console.log(`phi${i+1} = ${mec.phi_i[i]*180/pi}, psi${i+1} = ${mec.psi_i[i]*180/pi}`)
        }

        angl.exe(ctx2)
}   

function autoangles() {
    if (panel3.getValue("autom. Zwischenwinkel")) {
        var tempphi2 = (mec.phi_i[0]+((mec.phi_i[2] - mec.phi_i[0])/2))*180/pi,
            temppsi2 = (mec.psi_i[0]+((mec.psi_i[2] - mec.psi_i[0])/2))*180/pi;
            // console.log(`phi 2 = ${tempphi2},  psi 2 = ${temppsi2}`)

        panel3.setValue("φ2", tempphi2) //Math.round(tempphi2)) 
              .setValue("ψ2", temppsi2) //Math.round(temppsi2))
              .disableControl("φ2")
              .disableControl("ψ2")
    } else {
        panel3.enableControl("φ2")
              .enableControl("ψ2")
    }
    angles();
}

function render() {
    if (dirty) {
        position();
        world.exe(ctx);
        dirty = false;
    }
    requestAnimationFrame(render);
}

function norm(value, min, max) {
    return (value - min)/(max - min);
}

// cross product; takes objects with at least 2 dimensions and returns a 3d object
function cross(a,b) {
    var az = (a.z != 0) ? (a.z || 1) : 0,
        bz = (b.z != 0) ? (b.z || 1) : 0;

    return {x: a.y*bz - az*b.y , y: az*b.x - a.x*bz , z: a.x*b.y  -  a.y*b.x};
}

function evaluate() {
    mec.KML;
    mec.a = mec.d/mec.K1;
    mec.c = mec.d/mec.K2;
    mec.b = Math.sqrt(mec.a*mec.a + mec.c*mec.c + mec.d*mec.d - 2*mec.a*mec.c*mec.K3);

    console.log("a = " + mec.a + ",   b = " + mec.b + ",   c = " + mec.c  );

    panel.setRangeParameters("φ", mec.phi_i[0]*180/pi, mec.phi_i[2]*180/pi, 1);

    panel._controls["φ"].setValue(Math.round(mec.phi_i[0]*180/pi))

    evaluated = true;
    transfunc(); // testing
    updateLinks();
    
}

function transfunc() {
    mec.tf = [];

    if (evaluated) {
        var savedPhi = mec.phi;
        min = +panel._controls["φ"].control.min,
        max = +panel._controls["φ"].control.max;

    for (mec.phi=min; mec.phi<max; mec.phi+=0.25) {
        mec.phi *= pi/180;
        mec.tf.push(+(mec.phi*180/pi).toFixed(2), +(mec.psi*180/pi).toFixed(2));
        mec.phi *= 180/pi;
    }
    mec.phi = savedPhi;
    } else {
        return;
    }
    plotTransfunc();
}

// to make sure that there is no psi2 input that leads to singularity
function checkSing(value) { 
    if (Math.abs(value*pi/180 - mec.singularPsi2) < mec.meceps) {
        var outofrange = (mec.singularPsi2 - (mec.meceps + v2.EPS))*180/pi;
        setTimeout(function(){ panel3._controls["ψ2"].setValue(outofrange); evaluate(); }, 10); // needed to "refresh" inputfield
        return outofrange;
    } else {
        return value;  // value is not in epsilon range
    }
    return;
}

function updateLinks() {
    panel.setValue("Gliedlängen:", `a = ${Math.abs(+mec.a.toFixed(2))} \nb = ${Math.abs(+mec.b.toFixed(2))} \nc = ${Math.abs(+mec.c.toFixed(2))}`);
}


var cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    cnv2 = document.getElementById('c2'),
    ctx2 = cnv2.getContext('2d'),
    cnv3 = document.getElementById('c3'),
    ctx3 = cnv3.getContext('2d'),
    width = cnv.width = cnv2.width = window.innerWidth,
    height = cnv.height = cnv2.height = window.innerHeight,

    pi = Math.PI,

    mec = {
        phi:0,
        phi_i: [30/180*pi,60/180*pi,90/180*pi], // predefined angles
        psi_i: [25.015729367054092/180*pi,65.01572937118497/180*pi,115.01572943128093/180*pi], // predefined angles
        a:100,
        b:200,
        c:360,
        d:200,

        step: 0,
        largeNum: 999999999,
        meceps: 0.001, // rad ~= 0.23 deg

        assembly:1,  // direction of mec. assembly, found in mue of theta
        warped: false,
        tf: [],

        //######################################################################
        //#            Loesung
        //######################################################################

        K1: 0, K2: 0, K3: 0,

        //######################################################################
        //#            Matlab
        //######################################################################
        get KML() {
            var phi1 = mec.phi_i[0], phi2 = mec.phi_i[1], phi3 = mec.phi_i[2],
                psi1 = mec.psi_i[0], psi2 = mec.psi_i[1], psi3 = mec.psi_i[2],
                denominator = Math.cos(phi1)*Math.cos(psi2) - Math.cos(phi2)*Math.cos(psi1) - Math.cos(phi1)*Math.cos(psi3) + Math.cos(phi3)*Math.cos(psi1) + Math.cos(phi2)*Math.cos(psi3) - Math.cos(phi3)*Math.cos(psi2);

                // Matrizenlösung (rein Matlab)
                K1 = -(Math.cos(phi1 - psi1)*Math.cos(phi2) - Math.cos(phi1 - psi1)*Math.cos(phi3) - Math.cos(phi2 - psi2)*Math.cos(phi1) + Math.cos(phi2 - psi2)*Math.cos(phi3) + Math.cos(phi3 - psi3)*Math.cos(phi1) 
                         - Math.cos(phi3 - psi3)*Math.cos(phi2))/denominator,  

                K2 = -(Math.cos(phi1 - psi1)*Math.cos(psi2) - Math.cos(phi1 - psi1)*Math.cos(psi3) - Math.cos(phi2 - psi2)*Math.cos(psi1) + Math.cos(phi2 - psi2)*Math.cos(psi3) + Math.cos(phi3 - psi3)*Math.cos(psi1) 
                         - Math.cos(phi3 - psi3)*Math.cos(psi2))/denominator,

                K3 = (Math.cos(phi1 - psi1)*Math.cos(phi2)*Math.cos(psi3) - Math.cos(phi1 - psi1)*Math.cos(phi3)*Math.cos(psi2) - Math.cos(phi2 - psi2)*Math.cos(phi1)*Math.cos(psi3) + Math.cos(phi2 - psi2)*Math.cos(phi3)*
                         Math.cos(psi1) + Math.cos(phi3 - psi3)*Math.cos(phi1)*Math.cos(psi2) - Math.cos(phi3 - psi3)*Math.cos(phi2)*Math.cos(psi1))/denominator;

            if (K1<0 || K2<0) {
                mec.warped = true;
            } else {
                mec.warped = false;
            }

            mec.K1 = K1;
            mec.K2 = K2;
            mec.K3 = K3;
            
            console.log("denominator = " + denominator);
            console.log("K1num = " + -(Math.cos(phi1 - psi1)*Math.cos(phi2) - Math.cos(phi1 - psi1)*Math.cos(phi3) - Math.cos(phi2 - psi2)*Math.cos(phi1) + Math.cos(phi2 - psi2)*Math.cos(phi3) + Math.cos(phi3 - psi3)*Math.cos(phi1) 
                         - Math.cos(phi3 - psi3)*Math.cos(phi2)));
            console.log("K1 = " + mec.K1 + "\nK2 = " + mec.K2 + "\nK3 = " + mec.K3);
            return; 
        },

        get singularPsi1() {
            return Math.acos((Math.cos(mec.phi_i[1])*Math.cos(mec.psi_i[2]) - Math.cos(mec.phi_i[2])*Math.cos(mec.psi_i[1]) + Math.cos(mec.phi_i[0])*(Math.cos(mec.psi_i[1])*Math.cos(mec.psi_i[2]))) / (Math.cos(mec.phi_i[1])-Math.cos(mec.phi_i[2])));
        },

        get singularPsi2() {
            return Math.acos(- (Math.cos(mec.psi_i[0])*(Math.cos(mec.phi_i[2])-Math.cos(mec.phi_i[1])) + Math.cos(mec.psi_i[2])*(Math.cos(mec.phi_i[1])-Math.cos(mec.phi_i[0]))) / (Math.cos(mec.phi_i[0])-Math.cos(mec.phi_i[2])));
        },

        get singularPsi3() {
            return Math.acos((Math.cos(mec.phi_i[0])*Math.cos(mec.psi_i[1]) - Math.cos(mec.phi_i[1])*Math.cos(mec.psi_i[0]) + Math.cos(mec.phi_i[2])*(Math.cos(mec.psi_i[0]) - Math.cos(mec.psi_i[1]))) / (Math.cos(mec.phi_i[0])-Math.cos(mec.phi_i[1])));
        },

        //######################################################################
        //#            Kinematik
        //######################################################################

        get ephi() { 
            return { x:Math.cos(this.phi), y:Math.sin(this.phi) }; 
        },
        

        get g() {
            return {x:this.d - this.a*Math.cos(this.phi), y:- this.a*Math.sin(this.phi)}; 
        },

        get gg() {
            return this.a*this.a + this.d*this.d - 2*this.a*this.d*Math.cos(this.phi); 
        },

        get theta() {
            var gg = this.gg, bb_gg = (this.b*this.b)/gg, g = this.g,
                lambda = 0.5*(bb_gg - this.c*this.c/gg + 1),
                mue = mec.assembly*Math.sqrt(bb_gg - lambda*lambda);
            return Math.atan2( (1/this.b)*(lambda*g.y + mue*g.x), (1/this.b)*(lambda*g.x - mue*g.y) );
        },

        get etheta() { 
            return { x:Math.cos(this.theta), y:Math.sin(this.theta)}; 
        },

        get psi() {
            var etheta = this.etheta;
                return Math.atan2( (1/this.c)*(this.b*etheta.y - this.g.y), (1/this.c)*(this.b*etheta.x - this.g.x) );
        },

        get epsi() { 
            return { x:Math.cos(this.psi), y:Math.sin(this.psi)}; 
        },

        //######################################################################
        //#            Punkte
        //######################################################################

        A0: {x:0, y:0},

        get B0() { 
            return {x:this.d, y:0} 
        },

        get A() { 
            return {x:this.A0.x + this.a*this.ephi.x, y:this.A0.y + this.a*this.ephi.y}; 
        },

        get B() { 
            return {x:this.B0.x + this.c*this.epsi.x, y:this.B0.y + this.c*this.epsi.y}; 
        }
    },

    g = g2(),
    angl = g2(),
    pol = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(255, 153, 0, 0.8)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    pol2 = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(129, 165, 148, 1)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    world = g2().clr().cartesian().style({foc:"white"})
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan(0.4*width, 0.3*height) // .pan((width - 400)/2, (height - 360)/2)
                .use(g)
                .use("nodfix").label("A0","se"),

    dirty = true,
    evaluated = false,
    init = false,

    panel = QuickSettings.create(10, 10, "Steuerung")
             .addImage("","https://jauhl.github.io/img/fhlogo.svg")

             .addRange("φ", 0, 360, mec.phi, 1, function(value) { mec.phi = value/180*pi; dirty = true;})

             .addNumber("d (rein horizontal)", 0, 500, mec.d, 1, function(value) { mec.d = value; angles(); dirty = true; evaluated = false; evaluate();})

             .addTextArea("Gliedlängen:")
             .setTextAreaRows("Gliedlängen:", 2)
             
             .addButton("Montagerichtung umkehren", function(value) { mec.assembly *= -1; transfunc(); dirty = true;})
             .addBoolean("Übertragungsfunktion", false, function(value) { value?cnv3.style.display = "block":cnv3.style.display = "none"; })
    ,

    panel3 = QuickSettings.create( width - 210, 10, "Winkelvorgaben")
             .addNumber("φ1", 0, 360, Math.round(mec.phi_i[0]*180/pi), "any", function(value) { mec.phi_i[0] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})
             .addNumber("φ2", 0, 360, Math.round(mec.phi_i[1]*180/pi), "any", function(value) { mec.phi_i[1] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})
             .addNumber("φ3", 0, 360, Math.round(mec.phi_i[2]*180/pi), "any", function(value) { mec.phi_i[2] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})

             .addNumber("ψ1", 0, 360, mec.psi_i[0]*180/pi, "any", function(value) { mec.psi_i[0] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})
             .addNumber("ψ2", 0, 360, mec.psi_i[1]*180/pi, "any", function(value) { mec.psi_i[1] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})
             .addNumber("ψ3", 0, 360, mec.psi_i[2]*180/pi, "any", function(value) { mec.psi_i[2] = value/180*pi; if (init) { angles(); dirty = true; evaluated = false;}})

             .setGlobalChangeHandler(evaluate) // for testing
;



/*
 *  Eventlistener
 */

window.onresize = function() {
    width = cnv.width = cnv2.width = window.innerWidth;
    height = cnv.height = cnv2.height = window.innerHeight;

    cnv3.style.left = width - cnv3.width + "px";
    cnv3.style.top = height - cnv3.height + "px";

    panel3.setPosition( width - 210, 10);

    world = g2().del().clr().cartesian().style({foc:"white"})
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan(0.4*width, 0.3*height) // .pan((width - 400)/2, (height - 360)/2)
                .use(g)
                .use("nodfix").label("A0","se");

    dirty = true;
    angles();
};



/*
 *  Initialisierung
 */

if (panel._content.clientHeight > (height - 20)) panel.setHeight(height-20);  // resize qs panel if necessary
if (panel3._content.clientHeight > (height - 20)) panel.setHeight(height-20);  // resize qs panel if necessary
cnv3.style.left = width - cnv3.width + "px";
cnv3.style.top = height - cnv3.height + "px";
g2.State.linkfill = "transparent";
init = true;  // allows angles() to work after all inputs have been added
angles();
evaluate();
render();
    
    </script> 
</body>
</html>