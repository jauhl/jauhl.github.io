<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Wendepolkonstruktion nach Bobillier</title>    
    <style>
        html, body {
            margin: 0px;
        }
        canvas {
            display: block;  /*keine scrollbars*/
        }
    </style>  
</head>

<body>       
    <canvas id="c"></canvas>
<!--       
    <script src="./libs/g2.min.js"></script>
    <script src="./libs/g2.mec.min.js"></script>
    <script src="./libs/v2.min.js"></script>
    <script src="./libs/quicksettings.min.js"></script>  
-->
    <script src="https://gitcdn.xyz/repo/goessner/g2/master/g2.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/g2-mec/master/g2.mec.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/v2/master/v2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/quicksettings/latest/quicksettings.min.js"></script> 

    <script>
    
function position() {
    g.del().style({foc:"white", foz:12})
     .bar2(mec.A, mec.B)
     .use("nod",mec.A).label("A","nw")
     .use("nod",mec.B).label("B","ne")
     .use("gnd",mec.B0).label("B0","se") 

    if (panel.getValue("Wendekreis anzeigen"))
        g.cir(mec.center.x, mec.center.y, mec.radius, {ls:"orange"})

    if (panel.getValue("alt. Wendekreis anzeigen"))
        g.cir(mec.centeralt.x, mec.centeralt.y, mec.radiusalt, {ls:"rgba(129, 165, 148, 1)"}) // alternativer Wendekreis

     // Schritt 1
     if(mec.step >= 1) {
        g.use("pol",mec.P).label("P","n")
         .lin(mec.A0.x - 2*width*mec.ephi.x, mec.A0.y - 2*width*mec.ephi.y, mec.A0.x + 2*width*mec.ephi.x, mec.A0.y + 2*width*mec.ephi.y, {ld:"@dashdot", ls:"rgba(255, 255, 255, 0.5)"})
         .lin(mec.B0.x - 2*width*mec.epsi.x, mec.B0.y - 2*width*mec.epsi.y, mec.B0.x + 2*width*mec.epsi.x, mec.B0.y + 2*width*mec.epsi.y, {ld:"@dashdot", ls:"rgba(255, 255, 255, 0.5)"})         
     }

     // Schritt 2
     if(mec.step >= 2) {
        g.use("nod",mec.I).label("I","se")
         .lin(mec.A.x - 2*width*mec.etheta.x, mec.A.y - 2*width*mec.etheta.y, mec.A.x + 2*width*mec.etheta.x, mec.A.y + 2*width*mec.etheta.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.5)"})
        if (mec.I.x < mec.A0.x || mec.I.x > mec.B0.x) {
            g.lin(mec.B0.x, mec.B0.y, mec.I.x, mec.I.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.5)"})  
        } else {
            g.lin(mec.B0.x, mec.B0.y, mec.A0.x, mec.A0.y, {ld:"@dash", ls:"rgba(255, 255, 255, 0.5)"}) 
        }
     }

     // Schritt 3
     if(mec.step >= 3) {
        g.lin(mec.I.x, mec.I.y, mec.P.x, mec.P.y, {ls:"rgba(255, 255, 255, 0.6)"}).mark("tick",0.49).mark("tick",0.51)    
     }

     // Schritt 4
     if(mec.step >= 4) {
        g.use("nod",mec.K).label("K","se")
         .lin(mec.P.x, mec.P.y, mec.K.x, mec.K.y, {ls:"rgba(255, 255, 255, 0.7)"}).mark("tick",0.49).mark("tick",0.51) 
     }

     // Schritt 6
     if(mec.step >= 6) {
        g.use(pol,mec.Wnew).label("W","se")
         .lin(mec.Aw.x, mec.Aw.y, mec.Wnew.x, mec.Wnew.y, {ld:"@dot", ls:"rgba(255, 255, 255, 0.9)"})
         .lin(mec.Bw.x, mec.Bw.y, mec.Wnew.x, mec.Wnew.y, {ld:"@dot", ls:"rgba(255, 255, 255, 0.9)"})
         .beg({x: mec.Aw.x, y: mec.Aw.y, w:pi + Math.atan2(mec.e_A0A.y, mec.e_A0A.x)})
            .rec(0, 0, -8, 8, {lw:2, ls:"rgba(126, 126, 118, 0.9)", fs:"rgba(255, 255, 255, 0.6)"})
         .end()
         .beg({x: mec.Bw.x, y: mec.Bw.y, w:Math.atan2(mec.e_B0B.y, mec.e_B0B.x)})
            .rec(0, 0, 8, 8, {lw:2, ls:"rgba(126, 126, 118, 0.9)", fs:"rgba(255, 255, 255, 0.6)"})
         .end()

        if (panel.getValue("alt. Wendepol (Schritt 6)"))
           g.use(pol2, mec.Walt).label("Walt","se")
     }

     // Schritt 5
     if(mec.step >= 5) {
        g.use("nod",mec.Aw).label("Aw","se")
         .use("nod",mec.Bw).label("Bw","se")
        if (v2.len(v2.dif(mec.K,mec.Aw)) >= v2.len(v2.dif(mec.Bw,mec.Aw))) {
           g.lin(mec.K.x, mec.K.y, mec.Aw.x, mec.Aw.y, {ls:"rgba(255, 255, 255, 0.8)"}).mark("tick",0.49).mark("tick",0.51);
        } else {
           g.lin(mec.Bw.x, mec.Bw.y, mec.Aw.x, mec.Aw.y, {ls:"rgba(255, 255, 255, 0.8)"}).mark("tick",0.49).mark("tick",0.51);
        }
     }  

     
}        

function render() {
    if (dirty) {
        position();
        world.exe(ctx);
        dirty = false;
    }
    requestAnimationFrame(render);
}

function updateOutput() {
    panel2.setValue("aktueller Schritt:", steps[mec.step]);
}

function norm(value, min, max) {  
    return (value - min)/(max - min);
}

// cross product; takes objects with at least 2 dimensions and returns a 3d object
function cross(a,b) {
    var az = (a.z != 0) ? (a.z || 1) : 0,
        bz = (b.z != 0) ? (b.z || 1) : 0;
    
    return {x: a.y*bz - az*b.y , y: az*b.x - a.x*bz , z: a.x*b.y  -  a.y*b.x};
}

var cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    width = cnv.width = window.innerWidth,
    height = cnv.height = window.innerHeight,

    pi = Math.PI,

    mec = {
        phi:60*pi/180,
        a:40,
        b:105,
        c:126,
        d:190,
        e:0,

        step: 0,
        largenNum: 999999999,

        //######################################################################
        //#            Loesung
        //######################################################################

        // Schritt 1
        get r() {
            var frac = this.ephi.y/this.ephi.x;
            return (this.A0.y - this.B0.y + (this.B0.x - this.A0.x)*(frac))/(this.epsi.y - (frac*this.epsi.x));
        },

        get P() {
            return (v2.isum(v2.scl(this.epsi,this.r), this.B0));
        },
        
        // Schritt 2
        get k() {
            var frac = this.etheta.y/this.etheta.x;
            return (this.A.y - this.A0.y + (this.A0.x - this.A.x)*(frac))/(this.ealpha.y - (frac*this.ealpha.x));
        },

        get I() {
            return (v2.isum(v2.scl(this.ealpha,this.k), this.A0));
        },
        
        // Schritt 4
        get e_A0B0() {
            return (v2.iunit(v2.dif(this.B0, this.A0)));
        },

        get e_AB() {
            return (v2.iunit(v2.dif(this.B, this.A)));
        },

        get s() {
            var frac = this.e_A0B0.y/this.e_A0B0.x;
            return (this.P.y - this.A.y + (this.A.x - this.P.x)*frac)/(this.e_AB.y - (frac*this.e_AB.x));
        },

        get K() {
            return (v2.isum(v2.scl(this.e_AB,this.s), this.A));
        },

        // Schritt 5
        get e_PI() {
            return (v2.iunit(v2.dif(this.I, this.P)));
        },

        get e_A0A() {
            return (v2.unit(this.A));
        },

        get e_B0B() {
            return (v2.iunit(v2.dif(this.B, this.B0)));
        },

        // numerisches Problem bei phi=0° und phi=360° (innere Steglage). frac sowie this.A0.y sind dort geometriebedingt 0. Als Folge wird durch 0 geteilt (verfahrensbedingt)
        get t() {
            var frac = this.e_PI.y/this.e_PI.x;
            return (this.K.y - this.A0.y + (this.A0.x - this.K.x)*frac)/(this.e_A0A.y - (frac*this.e_A0A.x));
        },

        get Aw() {
            return (v2.isum(v2.scl(this.e_A0A,this.t), this.A0));
        },

        get u() {
            var frac = this.e_PI.y/this.e_PI.x;
            return (this.K.y - this.B0.y + (this.B0.x - this.K.x)*frac)/(this.e_B0B.y - (frac*this.e_B0B.x));
        },

        get Bw() {
            return (v2.isum(v2.scl(this.e_B0B,this.u), this.B0));
        },

        // Schritt 6
        get v() {
            var frac = - mec.e_A0A.x/mec.e_A0A.y;
            return (mec.Aw.y - mec.Bw.y + (mec.Bw.x - mec.Aw.x)*frac)/(mec.e_B0B.x + (frac*mec.e_B0B.y));
        },

        get W() {
            return (v2.isum(v2.iscl(v2.tilde(mec.e_B0B),mec.v), mec.Bw));
        },

        get Wnew() { 
            var P1 =  v2.dif(mec.Aw,v2.iscl(v2.tilde(mec.e_A0A),-mec.largenNum)),
                P2 =  v2.dif(mec.Aw,v2.iscl(v2.tilde(mec.e_A0A),mec.largenNum)),
                P3 =  v2.dif(mec.Bw,v2.iscl(v2.tilde(mec.e_B0B),-mec.largenNum)),
                P4 =  v2.dif(mec.Bw,v2.iscl(v2.tilde(mec.e_B0B),mec.largenNum)),
                SP = cross(  cross(P1,P2),   cross(P3,P4) );
            SP;
            return {x: SP.x/SP.z, y: SP.y/SP.z};
        },

        // Wendekreis
        get rPW() {
            return v2.dif(mec.W,mec.P);
        },

        get center() {
            return v2.isum(v2.scl(mec.rPW,0.5),mec.P);
        },

        get radius() {
            return 0.5*v2.len(mec.rPW);
        },

        //######################################################################
        //#            alternativer Wendekreis
        //######################################################################

        get rPWalt() {
            return v2.dif(mec.Walt,mec.P);
        },

        get centeralt() {
            return v2.isum(v2.scl(mec.rPWalt,0.5),mec.P);
        },

        get radiusalt() {
            return 0.5*v2.len(mec.rPWalt);
        },

        //######################################################################
        //#            Wendepol nach Gl. 9.5 (Goessner)
        //######################################################################

        get rPA() {
            return v2.dif(mec.A, mec.P); //x
        },

        get rPB() {
            return v2.dif(mec.B, mec.P); //x
        },

        get rBB0() {
            return v2.dif(mec.B0, mec.B); //x
        },

        get rAA0() {
            return v2.dif(mec.A0, mec.A); //x
        },

        get Walt() {
            var rPArPA = v2.dot(mec.rPA,mec.rPA), //x
                rPBrPB = v2.dot(mec.rPB,mec.rPB),
                frac = 1 / v2.perp(mec.rPA,mec.rPB),
                scalar1 = rPBrPB * ((rPBrPB / v2.dot(mec.rBB0,mec.rPB)) + 1),
                scalar2 = rPArPA * ((rPArPA / v2.dot(mec.rAA0,mec.rPA)) + 1);

            // console.log(`rPArPA: ${rPArPA}\nrPBrPB: ${rPBrPB}\nfrac: ${frac}\nscalar1: ${scalar1}\nscalar2: ${scalar2}`);
                
            return v2.isum (v2.iscl( v2.idif( v2.iscl( v2.tilde(mec.rPA), scalar1), v2.iscl( v2.tilde(mec.rPB), scalar2) ),frac),mec.P);
        },


        get WWaltLen() {
            return v2.len(v2.dif(mec.Walt,mec.W));
        },

       
        //######################################################################
        //#            Kinematik
        //######################################################################

        get ephi() {
            return {x: Math.cos(this.phi), y: Math.sin(this.phi)};
        },
        
        get g() {
            return {x: this.d2*this.ealpha.x - this.a*this.ephi.x, y:  this.d2*this.ealpha.y - this.a*this.ephi.y};
        },
        
        get gg() {
            return this.a*this.a + this.d2*this.d2 - 2*this.a*this.d2*Math.cos(this.alpha - this.phi);
        },
        
        get d2() {
            return Math.sqrt(this.d*this.d+this.e*this.e);
        },
        
        get alpha() {
            return Math.atan(this.e/this.d);
        },
        
        get ealpha() {
            return {x: Math.cos(this.alpha), y: Math.sin(this.alpha)};
        },
        
        get theta() {
            var gg = this.gg, bb_gg = (this.b*this.b)/gg, g = this.g,
                lambda = 0.5 * (bb_gg - this.c*this.c/gg + 1),
                mue = Math.sqrt(bb_gg - lambda * lambda);
            return Math.atan2((1/this.b) * (lambda*g.y + mue*g.x), (1/this.b)*(lambda*g.x - mue*g.y))
        },
        
        get etheta() {
            return {x: Math.cos(this.theta), y: Math.sin(this.theta)};
        },
        
        get psi() {
            var etheta = this.etheta;
            return Math.atan2((1/this.c)*(this.b*etheta.y - this.g.y), (1/this.c)*(this.b*etheta.x - this.g.x))
        },
        
        get epsi() {
            return {x: Math.cos(this.psi), y: Math.sin(this.psi)};
        },

        //######################################################################
        //#            Punkte
        //######################################################################

        A0: {x:0, y:0},

        get B0() {
            return {x: this.A0.x + this.d, y: this.A0.y + this.e};
        },
        
        get A() {
            return {x: this.A0.x + this.a*this.ephi.x, y: this.A0.y + this.a*this.ephi.y};
        },
        
        get B() {
            return {x: this.B0.x + this.c*this.epsi.x, y: this.B0.y + this.c*this.epsi.y};
        }
    },

    g = g2(),
    pol = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(255, 153, 0, 0.8)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    pol2 = g2().cir(0,0,6,{ls:"@nodcolor",fs:"rgba(129, 165, 148, 1)",lwnosc:true})
               .cir(0,0,2.5,{ls:"@nodcolor",fs:"@nodcolor"});
    world = g2().clr().cartesian().style({foc:"white"})
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan((width - (mec.a + mec.d))/2, (height - mec.c)/2) 
                .use(g)
                .use("gnd").label("A0","se"),

    dirty = true,

    steps = {
        0: "Bekannt ist die Lage zweier Punkte (A, B) eines Gliedes, sowie deren Krümmungsmittelpunkte A\u2080 und B\u2080",
        1: "Ermittlung des Momentanpols P im Schnittpunkt der Geraden AA\u2080 und BB\u2080.",
        2: "Bestimmung des Relativpols I zwischen Kurbel und Schwinge im Schnittpunkt der Geraden AB und A\u2080B\u2080",
        3: "Festlegung der Kollineationsachse als Gerade durch P und I.",
        4: "Die Parallele zu A\u2080B\u2080 durch P liefert im Schnittpunkt mit AB den Hilfspunkt K.",
        5: "Die Parallele zu PI durch diesen Hilfspunkt K schneidet die Gerade AA\u2080 in Aw und die Gerade BB\u2080 in Bw. Aw und Bw liegen beide auf dem Wendekreis.",
        6: "Die Senkrechten in Aw zu AA\u2080 und in Bw zu BB\u2080 schneiden sich im Wendepol W."
    },

    panel = QuickSettings.create(10, 10, "Steuerung")
             .addImage("","https://jauhl.github.io/img/fhlogo.svg")
             .addProgressBar("Fortschritt", 6, mec.step, "numbers")
             .addButton("Schritt weiter ▶", function(value) { if(mec.step<6) {mec.step+=1; dirty = true; panel.setValue("Fortschritt", mec.step);} updateOutput();}) // ▶
             .addButton("Schritt zurück ◀", function(value) { if(mec.step>0) {mec.step-=1; dirty = true; panel.setValue("Fortschritt", mec.step);} updateOutput();}) // ◀
             .addBoolean("Wendekreis anzeigen", false, function() {dirty = true;})
             .addBoolean("alt. Wendekreis anzeigen", false, function() {dirty = true;})
             .addBoolean("alt. Wendepol (Schritt 6)", false, function() {dirty = true;})
             .addRange("φ", 0, 360, mec.phi*180/pi, 1, function(value) { mec.phi = value / 180 * pi; dirty = true;})
             .addNumber("a", 0, 300, mec.a, "any", function(value) { mec.a = value; dirty = true;})
             .addNumber("b", 0, 300, mec.b, "any", function(value) { mec.b = value; dirty = true;})  // "b", 0, 300, 150, 1
             .addNumber("c", 0, 300, mec.c, "any", function(value) { mec.c = value; dirty = true;})  // "c", 0, 300, 100, 1
             .addNumber("d (rein horizontal)", 10, 500, mec.d, 1, function(value) { mec.d = value; dirty = true;})
             .addNumber("e (rein vertikal)", -100, 100, mec.e, 1, function(value) { mec.e = value; dirty = true;}),

    panel2 = QuickSettings.create(width - 310, 10, "Output")
             .addTextArea("aktueller Schritt:")
             .setWidth(300)
;

/*
 *  Initialisierung
 */

window.onresize = function() {
    width = cnv.width = window.innerWidth;
    height = cnv.height = window.innerHeight;

    panel2.setPosition( width - 310, 10);

    world = g2().del().clr().cartesian().style({foc:"white", fs:"transparent"})  // wenn hier .del(), wendekreis fs transparent notwendig!
                .rec(-width,-height,2*width,2*height,{ls:"rgba(52, 76, 107, 1)",fs:"rgba(52, 76, 107, 1)"})  // blueprint blue rgba(52, 76, 107, 1)
                .grid("rgba(255, 255, 255, 0.1)",100)
                .grid("rgba(255, 255, 255, 0.1)",20)
                .pan((width - (mec.a + mec.d))/2, (height - mec.c)/2) 
                .use(g)
                .use("gnd").label("A0","se");

    dirty = true;
};

// Animation starten
updateOutput();
render();
    
    </script> 
</body>
</html>
