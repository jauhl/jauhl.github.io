<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Kurbelschwinge</title>
</head>

<body>
    <h2>Kurbelschwinge - Grundfall 4</h2>
    <canvas id="c" width="600" height="400" style="border-width:1px;border-style:solid"></canvas>
    <br>
    <label for="phislider">&phi;:
    <input type="range" id="phislider" style="width:550px;vertical-align:middle;padding:0" min="0" max="360" value="0">
    <output id="phiout" for="phislider">0</output><span id="grad">Â°</span>
    </label>

    <script src="https://gitcdn.xyz/repo/goessner/g2/master/src/g2.js"></script>
    
    <script>

let cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    phislider = document.getElementById('phislider'),
    phiout = document.getElementById('phiout')
    grad = document.getElementById('grad'),

    pi = Math.PI,

    phi = 0, // Laufvariable

    mec = {
        a:120,
        b:200,
        c:150,
        d:250,
        get ephi() { return { x:Math.cos(phi), y:Math.sin(phi) }; },
        get g()   { return {x:this.d - this.a*Math.cos(phi), y:- this.a*Math.sin(phi)}; },
        get gg()  { return this.a*this.a + this.d*this.d - 2*this.a*this.d*Math.cos(phi); },
        get theta() {
            let gg = this.gg, bb_gg = (this.b*this.b)/gg, g = this.g,
                lambda = 0.5*(bb_gg - this.c*this.c/gg + 1),
                mue = Math.sqrt(bb_gg - lambda*lambda);
            return Math.atan2( (1/this.b)*(lambda*g.y + mue*g.x), (1/this.b)*(lambda*g.x - mue*g.y) )
        },
        get etheta() { return { x:Math.cos(this.theta), y:Math.sin(this.theta)}; },
        get psi() {
            let etheta = this.etheta;
            return Math.atan2( (1/this.c)*(this.b*etheta.y - this.g.y), (1/this.c)*(this.b*etheta.x - this.g.x) )
        },
        get epsi() { return { x:Math.cos(this.psi), y:Math.sin(this.psi)}; },

        // Gelenkpunkte
        A0: {x:0, y:0},
        get B0() { return {x:this.d, y:0} },
        get A() { return {x:this.A0.x + this.a*this.ephi.x, y:this.A0.y + this.a*this.ephi.y}; },
        get B() { return {x:this.B0.x + this.c*this.epsi.x, y:this.B0.y + this.c*this.epsi.y}; }
    },

    g = g2(),

    // baut und initialisiert statische Umgebung
    world = g2().clr().view({x:150,y:150,cartesian:true})
                .use({grp:g})
                .nodfix()
                .nodfix(mec.B0),

    dirty = true  // wenn true gibt es etwas zu aktualisieren
    ;

function position() {
    g.del()
     .link2({pts:[mec.A0.x, mec.A0.y, mec.A.x, mec.A.y, mec.B.x, mec.B.y, mec.B0.x, mec.B0.y ], closed:false})
     .nod(mec.A)
     .nod(mec.B)
}

function render() {
    if (dirty) {
        position();  // aktualisiere Position
        world.exe(ctx);  // rendert world in den Context
        dirty = false;
    }
    requestAnimationFrame(render);  // asynchroner callback von render(), keine Rekursion!
}

function setPhi() {
    if (phislider.value != phiout.value) {
        phi = phislider.value*pi/180;
        if (Math.sqrt(mec.gg) < (mec.b + mec.c)) {
            phiout.innerHTML = phislider.value;
            phiout.style["color"] = "black";
            grad.hidden = false;
            dirty = true;
        } else {
            phiout.style["color"] = "red";
            phiout.innerHTML = "unzulaessiger Bereich";
            grad.hidden = true;
        }
    }
}

/*
 *  Initialisierung
 */

// Eventlistener hinzufuegen
phislider.addEventListener("input",setPhi);

// Animation starten
render();

    </script>
</body>
</html>
