<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Kreuzschieber</title>
</head>

<body>
    <h2>Kreuzschieber - Grundfall 2</h2>
    <canvas id="c" width="450" height="300" style="border-width:1px;border-style:solid"></canvas>
    <br>
    <label for="s1slider">s1:
    <input type="range" id="s1slider" style="width:380px;vertical-align:middle;padding:0" min="-150" max="190" value="0">
    <output id="s1out" for="s1slider">0</output>mm
    </label>

    <script src="https://gitcdn.xyz/repo/goessner/g2/master/src/g2.js"></script>
    
    <script>

let cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    s1slider = document.getElementById('s1slider'),
    s1out = document.getElementById('s1out'),

    pi = Math.PI,

    s1 = 0, // Laufvariable

    mec = {
        l: 100,
        alpha: 30*pi/180,
        get g() { return {x:s1, y:0}; },
        get e2() { return {x:Math.cos(pi - this.alpha), y:Math.sin(pi - this.alpha)} },
        get s2() { let ge2  = this.g.x*this.e2.x + this.g.y*this.e2.y,
                       ge2g = (this.g.x*(-this.e2.y) + this.g.y*this.e2.x);
                   return ge2 + Math.sqrt( this.l*this.l - ge2g*ge2g ); },

        // eigentlich nicht benoetigt
        get phi() { return Math.atan2( (1/this.l)*this.s2*this.e2.y, (1/this.l)*this.s2*(this.e2.x - s1) ); },
        get ephi() { return {x:Math.cos(this.phi), y:Math.sin(this.phi)}; },

        // Gelenkpunkte
        get A() { return {x:s1, y:0}; },
        get B() { let s2 = this.s2; return {x:s2*this.e2.x, y:s2*this.e2.y}; }
    },

    g = g2(),

    // baut und initialisiert statische Umgebung
    world = g2().clr().view({x:220,y:150,cartesian:true})
                .beg({ld:[1,5,15,5], ls:"grey", lw:2})
                    .lin({x1:-300,y1:0,x2:300,y2:0})
                    .lin({x1:300*mec.ephi.x, y1:300*mec.ephi.y, x2:-300*mec.ephi.x, y2:-300*mec.ephi.y})  // geht nur weil Initialzustand phi == alpha
                .end()
                .use({grp:g}),

    dirty = true  // wenn true gibt es was zu aktualisieren
    ;

function position() {
    g.del()
     .slider({x:mec.A.x, y:mec.A.y, w:0, fs:"@nodfill"})
     .slider({x:mec.B.x, y:mec.B.y, w:-mec.alpha, fs:"@nodfill"})
     .lin({x1:mec.A.x, y1:mec.A.y, x2:mec.B.x, y2:mec.B.y, lw:3})
     .nod({x:mec.A.x, y:mec.A.y})
     .nod({x:mec.B.x, y:mec.B.y})
}

function render() {
    if (dirty) {
        position();  // aktualisiere Position
        world.exe(ctx);  // rendert world in den Context
        dirty = false;
    }
    requestAnimationFrame(render);  // asynchroner callback von render(), keine Rekursion!
}

function sets1() {
    if (s1slider.value != s1out.value) {
        s1 = s1slider.value;
        s1out.innerHTML = s1slider.value;
        dirty = true;
    }
}

/*
 *  Initialisierung
 */

// Eventlistener hinzufuegen
s1slider.addEventListener("input",sets1);

// Animation starten
render();

    </script>
</body>
</html>
