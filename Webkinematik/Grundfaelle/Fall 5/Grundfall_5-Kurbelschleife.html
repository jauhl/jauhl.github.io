<!doctype html>
<html>
<head>
    <meta charset='utf-8'>
    <title>Kurbelschleife</title>      
</head>

<body>
    <h2>Kurbelschleife - Grundfall 5</h2>             
    <canvas id="c" width="400" height="300" style="border-width:1px;border-style:solid"></canvas>
    <br>
    <label for="phislider">&phi;:
    <input type="range" id="phislider" style="width:330px;vertical-align:middle;padding:0" min="0" max="360" value="0">
    <output id="phiout" for="phislider">0</output>Â°
    </label>
     
    <script src="https://gitcdn.xyz/repo/goessner/g2/master/g2.min.js"></script>
    <script src="https://gitcdn.xyz/repo/goessner/g2-mec/master/g2.mec.min.js"></script>    

    <script>

var cnv = document.getElementById('c'),
    ctx = cnv.getContext('2d'),
    phislider = document.getElementById('phislider'),
    phiout = document.getElementById('phiout'), 

    pi = Math.PI,

    phi = 0, // Laufvariable

    a = 50, d = 3*a, e = 3/2*a,
    smax = Math.sqrt((a + d)*(a + d) - e*e),

    mec = {
        get ephi() { return {x:Math.cos(phi), y:Math.sin(phi)}; },
        get g()   { return {x:d - a*Math.cos(phi), y:-a*Math.sin(phi)}; },
        get gg()  { return a*a + d*d - 2*a*d*Math.cos(phi); },
        get s() { return Math.sqrt(this.gg - e*e); },
        get psi() {
            return Math.atan2( (1/this.gg)*(-e*this.g.y + this.s*this.g.x), (1/this.gg)*(-e*this.g.x - this.s*this.g.y) )
        },
        get epsi() { return { x:Math.cos(this.psi), y:Math.sin(this.psi)}; },

        // Gelenkpunkte
        A0: {x:0, y:0},
        B0: {x:d, y:0},
        get A() { return {x:a*this.ephi.x, y:a*this.ephi.y}; },
        get B() { return {x:this.B0.x + e*this.epsi.x, y:this.B0.y + e*this.epsi.y}; },
        get C() { return {x:this.B.x + (smax + 25)*(- this.epsi.y), y:this.B.y + (smax + 25)*this.epsi.x}; }
    },  
 
    g = g2(),

    // baut und initialisiert statische Umgebung
    world = g2().clr().cartesian()
                .pan(150, 180) // Nullpunkt verschoben   
                .use(g)
                .use("nodfix")
                .use("nodfix", mec.B0),

    dirty = true  // wenn true gibt es was zu aktualisieren
    ;

function position() {
    g.del()
     .link2([mec.B0.x, mec.B0.y, mec.B.x, mec.B.y, mec.C.x, mec.C.y], false)
     .slider(mec.A, (mec.psi+pi/2), {fs:"@nodfill"})
     .bar2(mec.A0, mec.A)
     .use("nod",mec.A)
}        

function render() {
    if (dirty) {
        position();  // aktualisiere Position
        world.exe(ctx);  // rendert world in den Context
        dirty = false;
    }
    requestAnimationFrame(render);  // asynchroner callback von render(), keine Rekursion!
}

function setPhi() {
    if (phislider.value != phiout.value) {
        phi = phislider.value*pi/180;
        phiout.innerHTML = phislider.value;
        dirty = true;
    }
}

/*
 *  Initialisierung
 */

// Eventlistener hinzufuegen
phislider.addEventListener("input",setPhi);

// Animation starten
render();

    </script>
</body>
</html>
